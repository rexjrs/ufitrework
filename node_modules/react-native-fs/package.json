{
  "_args": [
    [
      {
        "raw": "react-native-fs@^2.3.3",
        "scope": null,
        "escapedName": "react-native-fs",
        "name": "react-native-fs",
        "rawSpec": "^2.3.3",
        "spec": ">=2.3.3 <3.0.0",
        "type": "range"
      },
      "/Users/irexjr/Projects/UFIT"
    ]
  ],
  "_from": "react-native-fs@>=2.3.3 <3.0.0",
  "_id": "react-native-fs@2.3.3",
  "_inCache": true,
  "_location": "/react-native-fs",
  "_nodeVersion": "6.2.2",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/react-native-fs-2.3.3.tgz_1496343279791_0.49067480210214853"
  },
  "_npmUser": {
    "name": "hagen",
    "email": "hhuebel@itinance.com"
  },
  "_npmVersion": "4.5.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "react-native-fs@^2.3.3",
    "scope": null,
    "escapedName": "react-native-fs",
    "name": "react-native-fs",
    "rawSpec": "^2.3.3",
    "spec": ">=2.3.3 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/",
    "/react-native-cacheable-image"
  ],
  "_resolved": "https://registry.npmjs.org/react-native-fs/-/react-native-fs-2.3.3.tgz",
  "_shasum": "94c0d9699ec20405f30b79a69b6d8b96d2a4851b",
  "_shrinkwrap": null,
  "_spec": "react-native-fs@^2.3.3",
  "_where": "/Users/irexjr/Projects/UFIT",
  "author": {
    "name": "Johannes Lumpe",
    "email": "johannes@lum.pe",
    "url": "https://github.com/johanneslumpe"
  },
  "bugs": {
    "url": "https://github.com/itinance/react-native-fs/issues"
  },
  "dependencies": {
    "base-64": "^0.1.0",
    "utf8": "^2.1.1"
  },
  "description": "Native filesystem access for react-native",
  "devDependencies": {
    "flow-bin": "0.28.0",
    "react": "^15.4.2",
    "react-native": "^0.40.0"
  },
  "directories": {},
  "dist": {
    "shasum": "94c0d9699ec20405f30b79a69b6d8b96d2a4851b",
    "tarball": "https://registry.npmjs.org/react-native-fs/-/react-native-fs-2.3.3.tgz"
  },
  "gitHead": "4cc039cc330e5313e02d2f7819273a0e7a88999c",
  "homepage": "https://github.com/itinance/react-native-fs#readme",
  "keywords": [
    "react-component",
    "react-native",
    "ios",
    "android",
    "fs",
    "filesystem",
    "download",
    "upload",
    "file-transfer"
  ],
  "license": "MIT",
  "main": "FS.common.js",
  "maintainers": [
    {
      "name": "cjdell",
      "email": "me@chrisdell.info"
    },
    {
      "name": "hagen",
      "email": "hhuebel@itinance.com"
    },
    {
      "name": "johanneslumpe",
      "email": "johannes@johanneslumpe.de"
    }
  ],
  "name": "react-native-fs",
  "optionalDependencies": {},
  "readme": "## react-native-fs\n\nNative filesystem access for react-native\n\n## Changes for v2.3\n\n- React-Native 0.40 is minimum required for compiling on iOS (otherwise install an older release, see below)\n- Access to iOS-based \"assets-library\" is now supported with `copyAssetsFileIOS`\n- `readDir` will return now creation- and modification-time of files as with `stat()` (thanks @Ignigena)\n- optional connectionTimeout and readTimeout-Settings on `downloadFile` for Android (thanks @drunksaint)\n\n## Breaking change in v2.0\n\n- Removed attributes from `writeFile` and `appendFile` for iOS / Android consistency\n- `downloadFile` takes `options` object rather than parameters\n- `stopDownload` will cause the rejection of promise returned by `downloadFile`\n- `uploadFiles` promise result `response` property is now `body`\n- A boolean is no longer returned from any method except `exists`\n- `downloadFile` and `uploadFiles` return an object of the form `{ jobId: number, promise: Promise }`\n- `mkdir` takes optional 2nd parameter `options` for iOS users to set the `NSURLIsExcludedFromBackupKey` attribute\n\n## Usage (iOS)\n\nFirst you need to install react-native-fs:\n\n```\nnpm install react-native-fs --save\n```\n\n**Note:** If your react-native version is < 0.40 install with this tag instead:\n\n```\nnpm install react-native-fs@2.0.1-rc.2 --save\n```\n\nAs @a-koka pointed out, you should then update your package.json to\n`\"react-native-fs\": \"2.0.1-rc.2\"` (without the tilde)\n\n### Adding automatically with react-native link\n\nAt the command line, in your project folder, type:\n\n`react-native link react-native-fs`\n\nDone! No need to worry about manually adding the library to your project.\n\n### Adding with CocoaPods\n\nAdd the RNFS pod to your list of application pods in your Podfile, using the path from the Podfile to the installed module:\n\n```\npod 'RNFS', :path => './node_modules/react-native-fs'\n```\n\nInstall pods as usual:\n```\npod install\n```\n\n### Adding Manually in XCode\n\nIn XCode, in the project navigator, right click Libraries ➜ Add Files to [your project's name] Go to node_modules ➜ react-native-fs and add the .xcodeproj file\n\nIn XCode, in the project navigator, select your project. Add the `lib*.a` from the RNFS project to your project's Build Phases ➜ Link Binary With Libraries. Click the .xcodeproj file you added before in the project navigator and go the Build Settings tab. Make sure 'All' is toggled on (instead of 'Basic'). Look for Header Search Paths and make sure it contains both `$(SRCROOT)/../react-native/React` and `$(SRCROOT)/../../React` - mark both as recursive.\n\nRun your project (Cmd+R)\n\n## Usage (Android)\n\nAndroid support is currently limited to only the `DocumentDirectory`. This maps to the app's `files` directory.\n\nMake alterations to the following files:\n\n* `android/settings.gradle`\n\n```gradle\n...\ninclude ':react-native-fs'\nproject(':react-native-fs').projectDir = new File(settingsDir, '../node_modules/react-native-fs/android')\n```\n\n* `android/app/build.gradle`\n\n```gradle\n...\ndependencies {\n    ...\n    compile project(':react-native-fs')\n}\n```\n\n* register module (in MainActivity.java)\n\n  * For react-native below 0.19.0 (use `cat ./node_modules/react-native/package.json | grep version`)\n\n```java\nimport com.rnfs.RNFSPackage;  // <--- import\n\npublic class MainActivity extends Activity implements DefaultHardwareBackBtnHandler {\n\n  ......\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    mReactRootView = new ReactRootView(this);\n\n    mReactInstanceManager = ReactInstanceManager.builder()\n      .setApplication(getApplication())\n      .setBundleAssetName(\"index.android.bundle\")\n      .setJSMainModuleName(\"index.android\")\n      .addPackage(new MainReactPackage())\n      .addPackage(new RNFSPackage())      // <------- add package\n      .setUseDeveloperSupport(BuildConfig.DEBUG)\n      .setInitialLifecycleState(LifecycleState.RESUMED)\n      .build();\n\n    mReactRootView.startReactApplication(mReactInstanceManager, \"ExampleRN\", null);\n\n    setContentView(mReactRootView);\n  }\n\n  ......\n\n}\n```\n\n  * For react-native 0.19.0 and higher\n```java\nimport com.rnfs.RNFSPackage; // <------- add package\n\npublic class MainActivity extends ReactActivity {\n   // ...\n    @Override\n    protected List<ReactPackage> getPackages() {\n      return Arrays.<ReactPackage>asList(\n        new MainReactPackage(), // <---- add comma\n        new RNFSPackage() // <---------- add package\n      );\n    }\n```\n\n  * For react-native 0.29.0 and higher ( in MainApplication.java )\n```java\nimport com.rnfs.RNFSPackage; // <------- add package\n\npublic class MainApplication extends Application implements ReactApplication {\n   // ...\n    @Override\n    protected List<ReactPackage> getPackages() {\n      return Arrays.<ReactPackage>asList(\n        new MainReactPackage(), // <---- add comma\n        new RNFSPackage() // <---------- add package\n      );\n    }\n```\n\n## Examples\n\n### Basic\n\n```javascript\n// require the module\nvar RNFS = require('react-native-fs');\n\n// get a list of files and directories in the main bundle\nRNFS.readDir(RNFS.MainBundlePath) // On Android, use \"RNFS.DocumentDirectoryPath\" (MainBundlePath is not defined)\n  .then((result) => {\n    console.log('GOT RESULT', result);\n\n    // stat the first file\n    return Promise.all([RNFS.stat(result[0].path), result[0].path]);\n  })\n  .then((statResult) => {\n    if (statResult[0].isFile()) {\n      // if we have a file, read it\n      return RNFS.readFile(statResult[1], 'utf8');\n    }\n\n    return 'no file';\n  })\n  .then((contents) => {\n    // log the file contents\n    console.log(contents);\n  })\n  .catch((err) => {\n    console.log(err.message, err.code);\n  });\n```\n\n### File creation\n\n```javascript\n// require the module\nvar RNFS = require('react-native-fs');\n\n// create a path you want to write to\nvar path = RNFS.DocumentDirectoryPath + '/test.txt';\n\n// write the file\nRNFS.writeFile(path, 'Lorem ipsum dolor sit amet', 'utf8')\n  .then((success) => {\n    console.log('FILE WRITTEN!');\n  })\n  .catch((err) => {\n    console.log(err.message);\n  });\n\n```\n\n### File deletion\n```javascript\n// create a path you want to delete\nvar path = RNFS.DocumentDirectoryPath + '/test.txt';\n\nreturn RNFS.unlink(path)\n  .then(() => {\n    console.log('FILE DELETED');\n  })\n  // `unlink` will throw an error, if the item to unlink does not exist\n  .catch((err) => {\n    console.log(err.message);\n  });\n```\n\n### File upload (iOS only)\n\n```javascript\n// require the module\nvar RNFS = require('react-native-fs');\n\nvar uploadUrl = 'http://requestb.in/XXXXXXX';  // For testing purposes, go to http://requestb.in/ and create your own link\n// create an array of objects of the files you want to upload\nvar files = [\n  {\n    name: 'test1',\n    filename: 'test1.w4a',\n    filepath: RNFS.DocumentDirectoryPath + '/test1.w4a',\n    filetype: 'audio/x-m4a'\n  }, {\n    name: 'test2',\n    filename: 'test2.w4a',\n    filepath: RNFS.DocumentDirectoryPath + '/test2.w4a',\n    filetype: 'audio/x-m4a'\n  }\n];\n\nvar uploadBegin = (response) => {\n  var jobId = response.jobId;\n  console.log('UPLOAD HAS BEGUN! JobId: ' + jobId);\n};\n\nvar uploadProgress = (response) => {\n  var percentage = Math.floor((response.totalBytesSent/response.totalBytesExpectedToSend) * 100);\n  console.log('UPLOAD IS ' + percentage + '% DONE!');\n};\n\n// upload files\nRNFS.uploadFiles({\n  toUrl: uploadUrl,\n  files: files,\n  method: 'POST',\n  headers: {\n    'Accept': 'application/json',\n  },\n  fields: {\n    'hello': 'world',\n  },\n  begin: uploadBegin,\n  progress: uploadProgress\n}).promise.then((response) => {\n    if (response.statusCode == 200) {\n      console.log('FILES UPLOADED!'); // response.statusCode, response.headers, response.body\n    } else {\n      console.log('SERVER ERROR');\n    }\n  })\n  .catch((err) => {\n    if(err.description === \"cancelled\") {\n      // cancelled by user\n    }\n    console.log(err);\n  });\n\n```\n\n## API\n\n### Constants\n\nThe following constants are available on the `RNFS` export:\n\n- `MainBundlePath` (`String`) The absolute path to the main bundle directory\n- `CachesDirectoryPath` (`String`) The absolute path to the caches directory\n- `DocumentDirectoryPath`  (`String`) The absolute path to the document directory\n- `TemporaryDirectoryPath` (`String`) The absolute path to the temporary directory (iOS only)\n- `LibraryDirectoryPath` (`String`) The absolute path to the NSLibraryDirectory (iOS only)\n- `ExternalDirectoryPath` (`String`) The absolute path to the external files, shared directory (android only)\n- `ExternalStorageDirectoryPath` (`String`) The absolute path to the external storage, shared directory (android only)\n\n### `readDir(dirpath: string): Promise<ReadDirItem[]>`\n\nReads the contents of `path`. This must be an absolute path. Use the above path constants to form a usable file path.\n\nThe returned promise resolves with an array of objects with the following properties:\n\n```\ntype ReadDirItem = {\n  ctime: date;     // The creation date of the file (iOS only)\n  mtime: date;     // The last modified date of the file\n  name: string;     // The name of the item\n  path: string;     // The absolute path to the item\n  size: string;     // Size in bytes\n  isFile: () => boolean;        // Is the file just a file?\n  isDirectory: () => boolean;   // Is the file a directory?\n};\n```\n\n### `readDirAssets(dirpath: string): Promise<ReadDirItem[]>`\n\nReads the contents of `dirpath ` in the Android app's assets folder.\n`dirpath ` is the relative path to the file from the root of the `assets` folder.\n\nThe returned promise resolves with an array of objects with the following properties:\n\n```\ntype ReadDirItem = {\n  name: string;     // The name of the item\n  path: string;     // The absolute path to the item\n  size: string;     // Size in bytes. \n  \t\t\t\t\t\t// Note that the size of files compressed during the creation of the APK (such as JSON files) cannot be determined. \n  \t\t\t\t\t\t// `size` will be set to -1 in this case.\n  isFile: () => boolean;        // Is the file just a file?\n  isDirectory: () => boolean;   // Is the file a directory?\n};\n```\n\nNote: Android only.\n\n### `readdir(dirpath: string): Promise<string[]>`\n\nNode.js style version of `readDir` that returns only the names. Note the lowercase `d`.\n\n### `stat(filepath: string): Promise<StatResult>`\n\nStats an item at `path`.\nThe promise resolves with an object with the following properties:\n\n```\ntype StatResult = {\n  ctime: date;     // The creation date of the file\n  mtime: date;     // The last modified date of the file\n  size: string;     // Size in bytes\n  mode: number;     // UNIX file mode\n  isFile: () => boolean;        // Is the file just a file?\n  isDirectory: () => boolean;   // Is the file a directory?\n};\n```\n\n### `readFile(filepath: string, encoding?: string): Promise<string>`\n\nReads the file at `path` and return contents. `encoding` can be one of `utf8` (default), `ascii`, `base64`. Use `base64` for reading binary files.\n\nNote: you will take quite a performance hit if you are reading big files\n\n### `readFileAssets(filepath:string, encoding?: string): Promise<string>`\n\nReads the file at `path` in the Android app's assets folder and return contents. `encoding` can be one of `utf8` (default), `ascii`, `base64`. Use `base64` for reading binary files.\n\n`filepath` is the relative path to the file from the root of the `assets` folder.\n\nNote: Android only.\n\n### `writeFile(filepath: string, contents: string, encoding?: string): Promise<void>`\n\nWrite the `contents` to `filepath`. `encoding` can be one of `utf8` (default), `ascii`, `base64`. `options` optionally takes an object specifying the file's properties, like mode etc.\n\n### `appendFile(filepath: string, contents: string, encoding?: string): Promise<void>`\n\nAppend the `contents` to `filepath`. `encoding` can be one of `utf8` (default), `ascii`, `base64`.\n\n### `write(filepath: string, contents: string, position?: number, encoding?: string): Promise<void>`\n\nWrite the `contents` to `filepath` at the given random access position. When `position` is `undefined` or `-1` the contents is appended to the end of the file. `encoding` can be one of `utf8` (default), `ascii`, `base64`.\n\n### `moveFile(filepath: string, destPath: string): Promise<void>`\n\nMoves the file located at `filepath` to `destPath`. This is more performant than reading and then re-writing the file data because the move is done natively and the data doesn't have to be copied or cross the bridge.\n\n### `copyFile(filepath: string, destPath: string): Promise<void>`\n\nCopies the file located at `filepath` to `destPath`.\n\nNote: On Android copyFile will overwrite `destPath` if it already exists. On iOS an error will be thrown if the file already exists.\n\n### `copyFileAssets(filepath: string, destPath: string): Promise<void>`\n\nCopies the file at `filepath` in the Android app's assets folder and copies it to the given `destPath ` path.\n\nNote: Android only. Will overwrite destPath if it already exists\n\n### `copyAssetsFileIOS(imageUri: string, destPath: string, width: number, height: number, scale : number = 1.0, compression : number = 1.0, resizeMode : string = 'contain'  ): Promise<string>`\n\niOS-ony: copies a file from camera-roll, that is prefixed with \"assets-library://asset/asset.JPG?...\"\nto a specific destination. It will download the original from iCloud if necessary.\nIf width and height is > 0, the image will be resized to a specific size and a specific compression rate. \nIf scale is below 1, the image will be scaled according to the scale-factor (between 0.0 and 1.0)\nThe resizeMode is also considered.\nFurther information: https://developer.apple.com/reference/photos/phimagemanager/1616964-requestimageforasset\nThe promise will on success return the final destination of the file, as it was defined in the destPath-parameter.\n\n### `unlink(filepath: string): Promise<void>`\n\nUnlinks the item at `filepath`. If the item does not exist, an error will be thrown.\n\nAlso recursively deletes directories (works like Linux `rm -rf`).\n\n### `exists(filepath: string): Promise<boolean>`\n\nCheck if the item exists at `filepath`. If the item does not exist, return false.\n\n### `existsAssets(filepath: string): Promise<boolean>`\n\nCheck in the Android assets folder if the item exists. `filepath` is the relative path from the root of the assets folder. If the item does not exist, return false.\n\n### `hash(filepath: string, algorithm: string): Promise<string>`\n\nReads the file at `path` and returns its checksum as determined by `algorithm`, which can be one of `md5`, `sha1`, `sha224`, `sha256`, `sha384`, `sha512`.\n\n### `mkdir(filepath: string, options?: MkdirOptions): Promise<void>`\n\n```\ntype MkdirOptions = {\n  NSURLIsExcludedFromBackupKey?: boolean; // iOS only\n};\n```\n\nCreate a directory at `filepath`. Automatically creates parents and does not throw if already exists (works like Linux `mkdir -p`).\n\n(IOS only): The `NSURLIsExcludedFromBackupKey` property can be provided to set this attribute on iOS platforms. Apple will *reject* apps for storing offline cache data that does not have this attribute.\n\n### `downloadFile(options: DownloadFileOptions): { jobId: number, promise: Promise<DownloadResult> }`\n\n```\ntype DownloadFileOptions = {\n  fromUrl: string;          // URL to download file from\n  toFile: string;           // Local filesystem path to save the file to\n  headers?: Headers;        // An object of headers to be passed to the server\n  background?: boolean;\n  progressDivider?: number;\n  begin?: (res: DownloadBeginCallbackResult) => void;\n  progress?: (res: DownloadProgressCallbackResult) => void;\n  connectionTimeout?: number // only supported on Android yet\n  readTimeout?: number       // only supported on Android yet\n};\n```\n```\ntype DownloadResult = {\n  jobId: number;          // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n  statusCode: number;     // The HTTP status code\n  bytesWritten: number;   // The number of bytes written to the file\n};\n```\n\nDownload file from `options.fromUrl` to `options.toFile`. Will overwrite any previously existing file.\n\nIf `options.begin` is provided, it will be invoked once upon download starting when headers have been received and passed a single argument with the following properties:\n\n```\ntype DownloadBeginCallbackResult = {\n  jobId: number;          // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n  statusCode: number;     // The HTTP status code\n  contentLength: number;  // The total size in bytes of the download resource\n  headers: Headers;       // The HTTP response headers from the server\n};\n```\n\nIf `options.progress` is provided, it will be invoked continuously and passed a single argument with the following properties:\n\n```\ntype DownloadProgressCallbackResult = {\n  jobId: number;          // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n  contentLength: number;  // The total size in bytes of the download resource\n  bytesWritten: number;   // The number of bytes written to the file so far\n};\n```\n\nIf `options.progressDivider` is provided, it will return progress events that divided by `progressDivider`.\n\nFor example, if `progressDivider` = 10, you will receive only ten callbacks for this values of progress: 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100\nUse it for performance issues.\nIf `progressDivider` = 0, you will receive all `progressCallback` calls, default value is 0.\n\n(IOS only): `options.background` (`Boolean`) - Whether to continue downloads when the app is not focused (default: `false`)\n                           This option is currently only available for iOS, and you must [enable\n                           background fetch](https://www.objc.io/issues/5-ios7/multitasking/#background-fetch<Paste>)\n                           for your project in XCode. You only need to enable background fetch in `Info.plist` and set\n                           the fetch interval in `didFinishLaunchingWithOptions`. The `performFetchWithCompletionHandler`\n                           callback is handled by RNFS.\n\n\n### `stopDownload(jobId: number): void`\n\nAbort the current download job with this ID. The partial file will remain on the filesystem.\n\n### (iOS only) `uploadFiles(options: UploadFileOptions): { jobId: number, promise: Promise<UploadResult> }`\n\n`options` (`Object`) - An object containing named parameters\n\n```\ntype UploadFileOptions = {\n  toUrl: string;            // URL to upload file to\n  files: UploadFileItem[];  // An array of objects with the file information to be uploaded.\n  headers?: Headers;        // An object of headers to be passed to the server\n  fields?: Fields;          // An object of fields to be passed to the server\n  method?: string;          // Default is 'POST', supports 'POST' and 'PUT'\n  begin?: (res: UploadBeginCallbackResult) => void;\n  progress?: (res: UploadProgressCallbackResult) => void;\n};\n\n```\n```\ntype UploadResult = {\n  jobId: number;        // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n  statusCode: number;   // The HTTP status code\n  headers: Headers;     // The HTTP response headers from the server\n  body: string;         // The HTTP response body\n};\n```\n\nEach file should have the following structure:\n\n```\ntype UploadFileItem = {\n  name: string;       // Name of the file, if not defined then filename is used\n  filename: string;   // Name of file\n  filepath: string;   // Path to file\n  filetype: string;   // The mimetype of the file to be uploaded, if not defined it will get mimetype from `filepath` extension\n};\n```\n\nIf `options.begin` is provided, it will be invoked once upon upload has begun:\n\n```\ntype UploadBeginCallbackResult = {\n  jobId: number;        // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n};\n```\n\nIf `options.progress` is provided, it will be invoked continuously and passed a single object with the following properties:\n\n```\ntype UploadProgressCallbackResult = {\n  jobId: number;                      // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n  totalBytesExpectedToSend: number;   // The total number of bytes that will be sent to the server\n  totalBytesSent: number;             // The number of bytes sent to the server\n};\n```\n\nPercentage can be computed easily by dividing `totalBytesSent` by `totalBytesExpectedToSend`.\n\n### (iOS only) `stopUpload(jobId: number): Promise<void>`\n\nAbort the current upload job with this ID.\n\n### `getFSInfo(): Promise<FSInfoResult>`\n\nReturns an object with the following properties:\n\n```\ntype FSInfoResult = {\n  totalSpace: number;   // The total amount of storage space on the device (in bytes).\n  freeSpace: number;    // The amount of available storage space on the device (in bytes).\n};\n```\n\n### (iOS only) `pathForGroup(groupIdentifier: string): Promise<string>`\n\n`groupIdentifier` (`string`) Any value from the *com.apple.security.application-groups* entitlements list.\n\nReturns the absolute path to the directory shared for all applications with the same security group identifier. \nThis directory can be used to to share files between application of the same developer.\n\nInvalid group identifier will cause a rejection.\n\nFor more information read the [Adding an App to an App Group](https://developer.apple.com/library/content/documentation/Miscellaneous/Reference/EntitlementKeyReference/Chapters/EnablingAppSandbox.html#//apple_ref/doc/uid/TP40011195-CH4-SW19) section. \n\n## Test / Demo app\n\nTest app to demostrate the use of the module. Useful for testing and developing the module:\n\nhttps://github.com/cjdell/react-native-fs-test\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/itinance/react-native-fs.git"
  },
  "scripts": {
    "flow": "flow; test $? -eq 0 -o $? -eq 2",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "version": "2.3.3"
}
